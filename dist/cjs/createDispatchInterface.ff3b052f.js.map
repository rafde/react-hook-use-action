{"mappings":";;;;;;AAcO,SAAS,0CAIb,QAAoD,EAAE,OAAiB;IACzE,MAAM,kBAAkB,CAAE,QAA4C,SAAU;IAEhF,MAAM,MAAsD;QAC3D,SAAS,CAAA,UAAW,SAAU;yBAC7B;gBACA,MAAM;YACP;QACA,gBAAgB,CAAA,UAAW,SAAU;yBACpC;gBACA,MAAM;YACP;QACA,OAAO,CAAA,UAAW,SAAU;yBAC3B;gBACA,MAAM;YACP;QACA,QAAQ,OAAgB,EAAE,KAAc;YACvC,IAAK,OAAO,YAAY,YAAY,OAAO,YAAY,UACtD,OAAO,SAAU;gBAChB,SAAS;oBAAE,CAAE,QAAS,EAAE;gBAAO;gBAC/B,MAAM;YACP;YAGD,OAAO,SAAU;yBAChB;gBACA,MAAM;YACP;QACD;QACA,eAAe,OAAgB,EAAE,KAAc;YAC9C,IAAK,OAAO,YAAY,YAAY,OAAO,YAAY,UACtD,OAAO,SAAU;gBAChB,SAAS;oBAAE,CAAE,QAAS,EAAE;gBAAO;gBAC/B,MAAM;YACP;YAGD,OAAO,SAAU;yBAChB;gBACA,MAAM;YACP;QACD;IACD;IAEA,MAAM,QAAQ;aACb;IACD;IACA,IAAK,WAAW,QAAQ,OAAO,YAAY,UAC1C,OAAO,OAAO,MAAM,CAAE,iBAAiB;IAGxC,MAAM,gBAAgB,CAAC;IAKvB,IAAM,MAAM,QAAQ,QACnB,IAAK,CAAG,CAAA,QAAQ,GAAE,KAAO,OAAO,OAAO,CAAE,KAAM,KAAK,YACnD,aAAa,CAAE,KAA+C,GAAG,CAAE,SAAS,GAAG,OAAU,SAAU;qBAClG;kBACA;kBACA;QACD;IAIF,OAAO,MAAM,CAAE,MAAM,GAAG,EAAE;IAE1B,OAAO,OAAO,MAAM,CAAE,iBAAiB;AACxC","sources":["src/internal/createDispatchInterface.ts"],"sourcesContent":["import type { CTAState, } from '../types/CTAState';\nimport type { DefaultActionsRecord, } from '../types/DefaultActionsRecord';\nimport type {\n\tDispatchCTA,\n\tDispatchCTADefaultRecord,\n\tUseCTAReturnTypeDispatch,\n} from '../types/UseCTAReturnTypeDispatch';\n\nimport ctaReducer from './ctaReducer';\n\ntype UpdateCTAProps<\n\tInitial extends CTAState,\n> = Extract<Parameters<DispatchCTA<Initial, undefined>>[0], { type: 'update' | 'updateInitial' }>;\n\nexport function createDispatchInterface<\n\tInitial extends CTAState,\n\tActions,\n\tReturnValue = void,\n>( dispatch: DispatchCTA<Initial, Actions, ReturnValue>, actions?: Actions, ): UseCTAReturnTypeDispatch<Initial, Actions, ReturnValue> {\n\tconst dispatchWrapper = ( value: Parameters<typeof dispatch>[0], ) => dispatch( value, );\n\n\tconst cta: DispatchCTADefaultRecord<Initial, ReturnValue> = {\n\t\treplace: payload => dispatch( {\n\t\t\tpayload,\n\t\t\ttype: 'replace',\n\t\t}, ),\n\t\treplaceInitial: payload => dispatch( {\n\t\t\tpayload,\n\t\t\ttype: 'replaceInitial',\n\t\t}, ),\n\t\treset: payload => dispatch( {\n\t\t\tpayload,\n\t\t\ttype: 'reset',\n\t\t}, ),\n\t\tupdate( payload: unknown, value: unknown, ) {\n\t\t\tif ( typeof payload === 'number' || typeof payload === 'string' ) {\n\t\t\t\treturn dispatch( {\n\t\t\t\t\tpayload: { [ payload ]: value, },\n\t\t\t\t\ttype: 'update',\n\t\t\t\t} as UpdateCTAProps<Initial>, );\n\t\t\t}\n\n\t\t\treturn dispatch( {\n\t\t\t\tpayload,\n\t\t\t\ttype: 'update',\n\t\t\t} as UpdateCTAProps<Initial>, );\n\t\t},\n\t\tupdateInitial( payload: unknown, value: unknown, ) {\n\t\t\tif ( typeof payload === 'number' || typeof payload === 'string' ) {\n\t\t\t\treturn dispatch( {\n\t\t\t\t\tpayload: { [ payload ]: value, },\n\t\t\t\t\ttype: 'updateInitial',\n\t\t\t\t} as UpdateCTAProps<Initial>, );\n\t\t\t}\n\n\t\t\treturn dispatch( {\n\t\t\t\tpayload,\n\t\t\t\ttype: 'updateInitial',\n\t\t\t} as UpdateCTAProps<Initial>, );\n\t\t},\n\t};\n\n\tconst props = {\n\t\tcta,\n\t};\n\tif ( actions == null || typeof actions !== 'object' ) {\n\t\treturn Object.assign( dispatchWrapper, props, ) as UseCTAReturnTypeDispatch<Initial, Actions, ReturnValue>;\n\t}\n\n\tconst customActions = {} as Record<\n\t\tExclude<keyof Exclude<Actions, undefined>, keyof DefaultActionsRecord<Initial>>,\n\t\t( ...args: unknown[] ) => ReturnValue\n\t>;\n\n\tfor ( const type in actions ) {\n\t\tif ( !( type in cta ) && typeof actions[ type ] === 'function' ) {\n\t\t\tcustomActions[ type as unknown as keyof typeof customActions ] = ( payload, ...args ) => dispatch( {\n\t\t\t\tpayload,\n\t\t\t\ttype,\n\t\t\t\targs,\n\t\t\t} as Parameters<typeof ctaReducer<Initial, Actions>>[0]['nextCTAProps'], );\n\t\t}\n\t}\n\n\tObject.assign( props.cta, customActions, );\n\n\treturn Object.assign( dispatchWrapper, props, ) as UseCTAReturnTypeDispatch<Initial, Actions, ReturnValue>;\n}\n"],"names":[],"version":3,"file":"createDispatchInterface.ff3b052f.js.map"}